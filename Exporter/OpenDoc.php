<?php
namespace PHPExport\Exporter;

/**
 * Merges XML into an OpenDocument text (.odt) file.
 *
 * This class requires a basic template in .odt format, and an XSL 
 * stylesheet created from the template's content.xml file. The
 * class merges the XML content with the XSL stylesheet to create
 * a new version of content.xml, which is then added to the download file.
 *
 * If the setImageSource() method is called, the class embeds the images 
 * in the download file.
 *
 * Requires PHP Version 5.3 or later
 *
 * @version 1.0.0
 * @author Hemant Mann
 * @license http://opensource.org/licenses/MIT MIT
 */
class OpenDoc {
    /**
	 * @var \DOMDocument Stores the XML data to be merged into the download file
	 */
	protected $xmlInput;
	
	/**
	 * @var string Path to XSLT source file
	 */
	protected $xslt;
	
	/**
	 * @var string Path to document template
	 */
	protected $template;
	
	/**
	 * @var string The path to the directory containing the document template
	 */
	protected $dir;
	
	/**
	 * @var string Document template's filename extension (default: odt) 
	 */
	protected $extension = 'odt';
	
	/**
	 * @var string Name of download file (default: download.odt)
	 */
	protected $downloadFile = 'download.odt';
	
	/**
	 * @var string Path to temporary file that builds the download file
	 */
	protected $outputPath;
	
	/**
	 * @var string Content of download file in XML format generated by processing XML input and XSLT source
	 */
	protected $mergedContent;
	
	/**
	 * @var string Path to images folder
	 */
	protected $imageSource;
	
	/**
	 * @var string Name of images column in database or images element in XML source
	 */
	protected $imageColumn = 'images';
	
	/**
	 * @var \ZipArchive Loads document template and builds file for download
	 */
	protected $zip;
	
	/**
	 * @property-read string Error message if template can't be copied
	 */
	protected $fail;
	
	/**#@+
	 * Open Document namespaces
	 */
	const MANIFEST_NS = 'urn:oasis:names:tc:opendocument:xmlns:manifest:1.0';
	const OFFICE_NS = 'urn:oasis:names:tc:opendocument:xmlns:office:1.0';
	const DRAW_NS = 'urn:oasis:names:tc:opendocument:xmlns:drawing:1.0';
	const TEXT_NS = 'urn:oasis:names:tc:opendocument:xmlns:text:1.0';
	const XLINK_NS = 'http://www.w3.org/1999/xlink';
	/**#@-*/
	
	/**
	 * Loads XML source in preparation for creating download file
	 *
	 * Throws an exception if the XML is not well formed or a string
	 *
	 * @param string $xml Data formatted as XML to be inserted in document
	 */	
	public function __construct($xml) {
		$this->xmlInput = new \DOMDocument('1.0', 'utf-8');
		if (!$this->xmlInput->loadXML($xml)) {
			throw new \Exception ("Couldn't load the XML output. Check that it's valid XML and a string.");
		}
	}
	
	/**
	 * Loads the XSLT template
	 *
	 * Setting this value is required.
	 * Throws an exception if the file cannot be opened.
	 *
	 * @param string $xslt Path to the XSLT file
	 * @return void
	 */
	public function setXsltSource($xslt) {
		if (file_exists($xslt) && is_readable($xslt)) {
		    $this->xslt = $xslt;
		} else {
			throw new \Exception ("Can't open $xslt.");
		}
	}
	
	/**
	 * Loads the document template and checks that the folder is writable
	 *
	 * Setting this value is required.
	 * Throws an exception if the file cannot be found or if the folder isn't writable.
	 *
	 * @param string $path Path to document template
	 * @return void
	 */
	public function setDocTemplate($path) {
		if (file_exists($path) && is_readable($path)) {
			$this->checkFileType($path);
		    $this->template = $path;
			$this->dir = dirname($path);
		} else {
			throw new \Exception ("Can't open $path.");
		} 
		if (!is_writable($this->dir)) {
			throw new \Exception ("$this->dir must be writable.");
		}
	}
	
	/**
	 * Sets the location of the images folder
	 *
	 * Required only if the document template contains an image.
	 * Adds a trailing slash to the path if necessary.
	 * Throws an exception if the path is not a directory or readable.
	 *
	 * @param string $path Path to the images folder
	 * @return void
	 */
	public function setImageSource($path) {
		if (is_dir($path) && is_readable($path)) {
			if (strrpos($path, '/') != strlen($path) -1) {
				$path .= '/';
			}
			$this->imageSource = $path;
		} else {
			throw new \Exception ("The image source ($path) must be a readable directory/folder.");
		}
	}
	
	/**
	 * Specifies the name of the image column in the database or of the image element in the XML source
	 *
	 * Required only if images are used and if the value is different from the default.
	 *
	 * @param string|null $colname Column/element name (if null, defaults to images)
	 * @return void
	 */
	public function setImageColumn($colname = 'images') {
		$this->imageColumn = $colname;
	}
	
	/**
	 * Creates the download file
	 *
	 * The XSLT, document template, and image (if used) sources must be specified
	 * before this method is called.
	 *
	 * @param null|string Name of download file (if null, defaults to value of $downloadFile property
	 * @return void
	 */
	public function create($filename = null) {
		if (!is_null($filename)) {
			$this->checkFileType($filename);
			$this->downloadFile = basename($filename);
		} 
		$this->outputPath = $this->dir . '/' . $this->downloadFile;
		$xsltdoc = new \DOMDocument('1.0', 'utf-8');
		$xsltdoc->load($this->xslt);
		
		$processor = new \XSLTProcessor();
		$processor->importStylesheet($xsltdoc);
		$this->mergedContent = $processor->transformToXml($this->xmlInput);
		
		$this->generateDownload();
	}
	
	/**
	 * Magic get method that allows the protected $fail property to be accessed
	 *
	 * @param string $name Property name
	 * @return string
	 */
	 public function __get($name)
	 {
		if ($name == 'fail') {
			return $this->fail;
		}
	 }
	
	/**
	 * Checks that the document template has the correct filename extension
	 *
	 * Throws an exception if the extension is wrong
	 *
	 * @param string $path Path to document template
	 * @return void
	 */
	protected function checkFileType($path) {
		$ext = strtolower(pathinfo($path, PATHINFO_EXTENSION));
		if ($ext != 'odt') {
			throw new \Exception ('The document template must have an .odt extension.');
		}
	}
	
	/**
	 * Builds and downloads the generated file
	 *
	 * @return void
	 */
	protected function generateDownload() {
		if (copy($this->template, $this->outputPath)) {
			$this->zip = new \ZipArchive();
			$this->zip->open($this->outputPath);
			if (isset($this->imageSource)) {
				$this->addImages();
			}
		    $this->zip->addFromString('content.xml', $this->mergedContent);
			$this->zip->close();
			
			header('Content-Description: File Transfer');
		    header('Content-Type: application/vnd.oasis.opendocument.text');
			header('Content-Disposition: attachment; filename=' . $this->downloadFile);
			header('Content-Transfer-Encoding: binary');
			header('Expires: 0');
			header('Cache-Control: must-revalidate');
			header('Pragma: public');
			header('Content-Length: ' . filesize($this->outputPath));
			readfile($this->outputPath);
			unlink($this->outputPath);	
		} else {
			$this->fail = 'Sorry, unable to generate the requested file.';
		}
		
	}
	
	/**
	 * Adds images to the merged XML content
	 *
	 * @return void
	 */
	protected function addImages() {
		$doc = new \DOMDocument('1.0', 'utf-8');
		$doc->loadXML($this->mergedContent);
		$drawFrames = $doc->getElementsByTagNameNS(self::DRAW_NS, 'frame');
		$manifest = $this->zip->getFromName('META-INF/manifest.xml');
		$manifestUpdate = new \DOMDocument('1.0', 'utf-8');
		$manifestUpdate->loadXML($manifest);
		$manifestRoot = $manifestUpdate->documentElement;
		$fileEntries = $manifestUpdate->getElementsByTagNameNS(self::MANIFEST_NS, 'file-entry');
		$i = 0;
		$firstPic = null;
		foreach ($fileEntries as $entry) {
		    $fullPath = $entry->getAttributeNS(self::MANIFEST_NS, 'full-path');
		    if (strpos($fullPath, 'Pictures/') === 0) {
		        if (is_null($firstPic)) {
		            $firstPic = $i;
		        }
		        $manifestRoot->removeChild($entry);
		    }
		    $i++;
		}
	    $insertionPoint = $fileEntries->item($firstPic);
		$images = $this->getImageFilenames();
		$i = 0;
		foreach ($images as $image) {
			$drawFrame = $drawFrames->item($i);
			$drawFrame->setAttributeNS(self::DRAW_NS, 'draw:name', 'graphics' . ($i + 1));
			$drawFrame->setAttributeNS(self::DRAW_NS, 'draw:z-index', $i);
			$drawImages = $drawFrame->getElementsByTagNameNS(self::DRAW_NS, 'image');
			$drawImage = $drawImages->item(0);
			$mediaType = $this->getMediaType($image);
			$drawImage->setAttributeNS(self::XLINK_NS, 'text:href', 'Pictures/' . $image);
			$this->zip->addFile($this->imageSource . $image, 'Pictures/' . $image);
			$fileEntry = $manifestUpdate->createElementNS(self::MANIFEST_NS, 'manifest:file-entry');
			$fileEntry->setAttributeNS(self::MANIFEST_NS, 'manifest:full-path', 'Pictures/' . $image);
			$fileEntry->setAttributeNS(self::MANIFEST_NS, 'manifest:media-type', $mediaType);
			$manifestRoot->insertBefore($fileEntry, $insertionPoint);
			$i++;
		}
		$this->zip->addFromString('META-INF/manifest.xml', $manifestUpdate->saveXML());
		$this->mergedContent = $doc->saveXML();
	}
	
	/**
	 * Gets a list of image filesnames from the XML input
	 *
	 * @return array Array of image filenames
	 */
	protected function getImageFilenames() {
		$imageList = $this->xmlInput->getElementsByTagName('image');
		foreach ($imageList as $image) {
			$images[] = $image->nodeValue;
		}
		return $images;
	}
	
    /**
     * Gets the MIME type from an image's filename extension
     * 
     * @param string $image Image name
     * @return string MIME type
     */
	protected function getMediaType($image) {
	    $extension = strtolower(pathinfo($image, PATHINFO_EXTENSION));
	    switch ($extension) {
	    	case 'jpg':
	    	case 'jpeg':
	    	    return 'image/jpeg';
	    	case 'png':
	    	    return 'image/png';
	    	case 'gif':
	    	    return 'image/gif';
	    }
	}
}
